## 全局变量和局部变量
- 全局变量：作用域为所属的整个程序。
  定义形式：在函数外定义。  
       在函数内定义，但是不加 var 声明。  
       使用 window.变量名 的形式定义。（注：兼容性未知）  
       使用 window['变量名'] 的形式定义。（注：兼容性未知）
- 局部变量：作用域为所属的函数内部。
  定义形式：  
        在函数内部定义的变量。  
        函数中用到的形式参数。 
        
#### 代码实例
  ```javascript
    var a =0;                        //全局变量
    b =0;                                //全局变量
    function c() {
        var d =0;                //局部变量
        e =0;                        //全局变量
        return d;
    }
    console.log(a);                //0
    console.log(b);                //0
    console.log(c());                   //0
    console.log(e);                //0
    console.log(d);                //出错
```

#### 几种情况
1.局部变量的变量提升问题以及全局变量和局部变量重名的问题。
```javascript
var a = 0;
b = 0;
function c() {
console.log(a);
var a = 1;
console.log(a);
return a;
}
console.log(a);                //0
c();                                //undefined,1
```
理解：  
第一条打印结果为 0 ，其中的 变量a 指的是全局变量a；第二条打印结果为 undefined和1，因为在执行函数c 的时候，并非是从上到下依次执行的各条语句，而是先将定义变量的语句提前执行，其它语句的执行顺序不变。即函数c 中实际执行效果代码如下：
```javascript
function c() {
var a;
console.log(a);
a = 1;
console.log(a);
return a;
}
```
当在函数c中定义了一个与全局变量一样的局部变量a时，函数c内部就会重新定义一个局部变量a，并将之前定义的全局变量a覆盖，不过，这个局部变量a只是在函数c中有效。由此可知，在函数c中，当第一次打印a时，实际上只定义了局部变量a，而未赋值，所以打印结果为undefined，执行第二条打印局部变量a时已经对其进行了赋值，所以结果为1。

2.全局变量和某个函数中的局部变量重名，如何在该函数中获得同名全局变量的值。

```javascript
var a = 0;
function c() {
console.log(window.a);
var a = 1;
console.log(a);
return a;
}
c();                                //0,1
```
理解：  
在函数内部使用 window.变量名 或者 window['变量名'] 即可。
各自优缺点：

全局变量  
优点：  
可以减少变量的个数，减少由于实际参数和形式参数的数据传递带来的时间消耗。
缺点：  
全局变量保存在静态存储区，程序开始运行时为其分配内存，程序结束运行时释放其内存。相比于局部变量的动态分配/释放内存，全局变量的生命周期长，而且当全局变量数目较多时，会占用较大的内存。
使用全局变量会破坏函数的封闭性和独立性。一个函数本来是通过传参和返回值来进行输入输出，但是用了全局变量之后，该函数就可以不仅只通过原有的参数和返回进行输入输出，这样原有的封闭性就被破坏了，这也导致函数的可移植性降低。
当一个全局变量多次被不同的语句（函数）操作，全局变量的值容易变得不清晰，这便降低了程序的可读性，不利于在编码后进行调试和查错之类的操作。
局部变量  
优点：  
局部变量是程序动态分配内存的，所以生命周期短，不会造成长时间占用过多内存的情况。
局部变量定义在函数内部，限于函数内部调用，故能够有效的保证函数的封闭性。
即使在多个函数内部定义了多个同名局部变量，它们之间也不会相互影响。
缺点：  
局部变量中的数据在函数执行完后就会消失，故不利于数据的保留。
局部变量的使用范围有限，仅限于所属函数的内部。


 
