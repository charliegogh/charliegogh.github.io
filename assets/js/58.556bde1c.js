(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{258:function(t,e,r){"use strict";r.r(e);var o=r(0),b=Object(o.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("blockquote",[r("p",[t._v("问题：")])]),t._v(" "),r("p",[t._v("现有三个页面a , b , c , 递进关系，a页面router.push跳转至b，b再router.push跳转至c，c使用$router.replace()回到b，\n然后点击b页面的返回键，需要点击两次才能回到a页面。")]),t._v(" "),r("blockquote",[r("p",[t._v("需求：")])]),t._v(" "),r("p",[t._v("c保持router.replace至b方式不变，b页面返回键点击一次正常返回a页面")]),t._v(" "),r("blockquote",[r("p",[t._v("解决方法：")])]),t._v(" "),r("p",[t._v("使用replace方法之后，再使用router.go(-1)方法返回一次就可以。")]),t._v(" "),r("blockquote",[r("p",[t._v("原理：")])]),t._v(" "),r("ol",[r("li",[t._v("router.push : 跳转到新的页面，向history栈添加新一个新纪录，点击返回，返回到上一级页面。")]),t._v(" "),r("li",[t._v("router.replace: 打开新的页面，不会像history添加新纪录，而是直接替换掉当前记录。")]),t._v(" "),r("li",[t._v("router.go: 在history有记录的情况下，前进后退相应的页面。\n页面的跳转记录就是：a->b->c->b\n页面的堆栈记录则是：a->b->b\n那么返回的时候路线就是b->b->a，相当于b页面有两个，但由于b页面是一模一样的，所以视觉上是觉得点了两次返回键。\n那么解决的思路就很清晰了，减少history中的b的记录，就是在用b替换c页面记录同时，回退一页，记录就变成a->b，返回的时候自然是直接回到a。")])])])}),[],!1,null,null,null);e.default=b.exports}}]);