(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{242:function(e,s,t){"use strict";t.r(s);var a=t(0),n=Object(a.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"长列表性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#长列表性能优化"}},[e._v("#")]),e._v(" 长列表性能优化")]),e._v(" "),t("p",[e._v("vue会通过object.defineProperty对数据进行劫持，来实现视图数据的变化，有些时候的只是为了纯粹的数据展示，不会有任何的改变，就不需要再让vue\n劫持数据，在大量数据展示的情况下，这样就能够很明显的减少组件初始化的时间，可以通过object.freeze来冻结一个对象，一旦被冻结的对象就再也不能\n被修改了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('export default {\n  data: () => ({\n    users: {}\n  }),\n  async created() {\n    const users = await axios.get("/api/users");\n    this.users = Object.freeze(users);\n  }\n};\n')])])]),t("p",[e._v("另外这里只是冻结了users的值，引用不会被冻结，当我们需要reactive数据的时候，我们可以重新给users赋值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('export default {\n  data: () => ({\n    users: []\n  }),\n  async created() {\n    const users = await axios.get("/api/users");\n    this.users = Object.freeze(users);\n  },\n  methods:{\n    // 改变值不会触发视图响应\n    this.users[0] = newValue\n    // 改变引用依然会触发视图响应\n    this.users = newArray\n  }\n};\n')])])])])}),[],!1,null,null,null);s.default=n.exports}}]);